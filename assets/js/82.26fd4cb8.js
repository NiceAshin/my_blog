(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{499:function(s,a,t){"use strict";t.r(a);var v=t(2),l=Object(v.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"并发基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发基础"}},[s._v("#")]),s._v(" 并发基础")]),s._v(" "),a("blockquote",[a("p",[s._v("预计阅读时间：5 分钟")])]),s._v(" "),a("p",[s._v("线程安全性即当多个线程访问某个类时, 这个类始终能表现出正确的行为.")]),s._v(" "),a("p",[s._v("编写线程安全的代码, 核心是对状态访问进行管理, 特别是对可变得和共享的状态访问, 状态存储在实例或静态与中的数据, 状态可能包括其他依赖对象的域, 如HashMap的Map.Entry")]),s._v(" "),a("p",[s._v("并发编程中, 由于不恰当的执行时序二出现不正确结果现象称之为竟态条件.")]),s._v(" "),a("h2",{attrs:{id:"保证线程安全性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#保证线程安全性"}},[s._v("#")]),s._v(" 保证线程安全性")]),s._v(" "),a("ul",[a("li",[s._v("使用线程安全类")])]),s._v(" "),a("p",[s._v("使用AtomicLong, AtomicReference, ConcurrentHashMap等线程安全类.")]),s._v(" "),a("ul",[a("li",[s._v("适当的加锁")])]),s._v(" "),a("blockquote",[a("p",[s._v("每个java对象都可以用作一个实现同步的锁. 使用同步代码块时,代码快的作用范围应当尽量小, 避免出现活跃性问题. 尽量不要使用不同的加锁机制, 不仅会带来混乱, 也不会在性能和安全性上带来好处.")]),s._v(" "),a("p",[s._v("内置锁是可以重入的, 重入意味着获取锁的操作的粒度是线程而不是调用.")]),s._v(" "),a("p",[s._v("若使用同步来协调对某个变量的访问, 那么在访问这个变量的所有位置都要加锁, 且使用同一个锁.")]),s._v(" "),a("p",[s._v("可以将所有可变状态都封装到一个对象中, 然后使用这个对象的内置锁来对访问可变状态的代码路径进行同步.")]),s._v(" "),a("p",[s._v("即使每个方法都作为同步方法使用同一把锁, 但如果出现复合操作仍然需要额外的加锁机制.")])]),s._v(" "),a("ul",[a("li",[s._v("避免多个线程同一时间访问相同数据")])]),s._v(" "),a("h2",{attrs:{id:"控制对象的共享"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#控制对象的共享"}},[s._v("#")]),s._v(" 控制对象的共享")]),s._v(" "),a("h3",{attrs:{id:"对象的发布与逸出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的发布与逸出"}},[s._v("#")]),s._v(" 对象的发布与逸出")]),s._v(" "),a("hr"),s._v(" "),a("p",[s._v("发布指使对象能够在当前作用域之外的代码中使用. 当某个不该发布的对象被发布时, 这种情况称之为逸出.")]),s._v(" "),a("p",[a("strong",[s._v("发布对象的方式")]),s._v(":")]),s._v(" "),a("ul",[a("li",[s._v("将对象的引用保存在一个拥有的静态变量中")]),s._v(" "),a("li",[s._v("当发布一个对象时, 在这个对象的非私有域(非private修饰)中引用的所有对象也会被发布.")]),s._v(" "),a("li",[s._v("发布一个内部的类实例.")])]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"title"},[s._v("安全发布对象")]),a("ul",[a("li",[s._v("将对象的引用保存到volatile类型的域或者AtomicReference中")]),s._v(" "),a("li",[s._v("将对象的引用保存到某个正确构造对象的final域中.")]),s._v(" "),a("li",[s._v("将对象的引用保存到一个由锁保护的域中.")]),s._v(" "),a("li",[s._v("在静态初始化函数中初始化一个对象引用, 由JVM内部的同步机制来保证安全发布.")])])]),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"title"},[s._v("不安全发布")]),a("p",[s._v("this引用在构造方法中逸出. 当且仅当对象的构造方法返回时, 对象才处于可预测的和一致的状态")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    public class A{\n        public A(){\n            ...\n            B.doSomething(this);\n            ...\n        }\n    }\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("在构造方法中启动一个线程, 当对象在其构造方法中创建一个线程时, 无论是显示创建还是隐式创建, this引用都会被新创建的线程共享")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("    public class A {\n    \n        public A(){\n            ...\n               new Thread(() -> {...}).start().\n            ...\n        }\n    }\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])])]),a("h3",{attrs:{id:"线程封闭"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程封闭"}},[s._v("#")]),s._v(" 线程封闭")]),s._v(" "),a("hr"),s._v(" "),a("ul",[a("li",[s._v("数据只在单个线程内访问.")]),s._v(" "),a("li",[s._v("局部变量(栈封闭), ThreadLocal.")]),s._v(" "),a("li",[s._v("volatile的特殊线程封闭, 只要能够保证只有一条线程对volatile执行写入操作, 就可以安全的在这些共享的volatile变量上执行读写")])]),s._v(" "),a("h3",{attrs:{id:"对象的不变性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的不变性"}},[s._v("#")]),s._v(" 对象的不变性")]),s._v(" "),a("hr"),s._v(" "),a("ul",[a("li",[s._v("不可变对象一定是线程安全的, 它只有一种状态, 并且由构造方法控制.")]),s._v(" "),a("li",[s._v("不可变对象创建后其状态不能再修改, 所有域都是final的.")]),s._v(" "),a("li",[s._v("当需要一组相关数据以原子方式来执行某个操作时, 就可以考虑创建一个不可变类来包含这些数据")]),s._v(" "),a("li",[s._v("对象创建时, this引用没有逸出.")])]),s._v(" "),a("h2",{attrs:{id:"对象的组合"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的组合"}},[s._v("#")]),s._v(" 对象的组合")]),s._v(" "),a("ol",[a("li",[s._v("设计线程安全类")])]),s._v(" "),a("p",[s._v("设计线程安全类的基本要素: 找出构造对象状态的所有变量, 找出约束状态变量的不变性条件. 建立对象状态的并发访问策略.\n并发访问策略规定了如何将不变性, 线程封闭和加锁机制组合起来维护线程安全性, 还规定了哪些变量需要加锁保护")]),s._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[s._v("实例封闭")])]),s._v(" "),a("p",[s._v("将数据封装到对象内部, 将数据的访问限制在对象方法.")])])}),[],!1,null,null,null);a.default=l.exports}}]);