(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{527:function(t,s,a){"use strict";a.r(s);var v=a(2),_=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"服务部署"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务部署"}},[t._v("#")]),t._v(" 服务部署")]),t._v(" "),s("blockquote",[s("p",[t._v("预计阅读时间：5 分钟")])]),t._v(" "),s("p",[t._v("本文记录三种服务部署方式, 根据实际业务量使用. 1 打包部署, 2 docker , 3 k8s")]),t._v(" "),s("h2",{attrs:{id:"打包部署"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#打包部署"}},[t._v("#")]),t._v(" 打包部署")]),t._v(" "),s("p",[t._v("打包部署在微服务架构中已经无法满足需求, 它缺乏对技术栈的封装, 也无法约束服务对资源的消耗. 并且在同一机器上运行多个服务, 缺少隔离.")]),t._v(" "),s("h2",{attrs:{id:"docker"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker"}},[t._v("#")]),t._v(" docker")]),t._v(" "),s("p",[t._v("容器是一种部署机制, 是一种操作系统级的虚拟化机制, 它通常包含一个或多个在沙箱中运行的进程, 沙箱将其与其他容器隔离, 每个容器有自己的ip, 可以消除端口冲突. 创建容器时可以指定资源分配的大小")]),t._v(" "),s("p",[s("strong",[t._v("容器部署服务步骤")])]),t._v(" "),s("ol",[s("li",[t._v("创建Dockerfile文件, 用于描述如何构建Docker镜像")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[t._v("Dockerfile编写")]),s("ol",[s("li",[t._v("指定基础镜像")]),t._v(" "),s("li",[t._v("安装curl用于执行健康检查(可选的)")]),t._v(" "),s("li",[t._v("将jar复制到镜像中")]),t._v(" "),s("li",[t._v("容器启动时启动jar")])])]),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("将镜像上传到仓库中(dockerhub的私库)")])]),t._v(" "),s("li",[s("p",[t._v("运行镜像,可以使用docker compose以组的形式启动和停止")])])]),t._v(" "),s("h2",{attrs:{id:"k8s"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#k8s"}},[t._v("#")]),t._v(" k8s")]),t._v(" "),s("p",[t._v("k8s是docker的编排框架, docker之上的软件层, 可以将一组计算机硬件资源转变为用于运行服务的单一资源池")]),t._v(" "),s("p",[t._v("k8s在一组机器上运行(集群), 集群中的角色分为主节点和普通节点, 主节点负责管理集群, 普通节点是工作借点, 运行一个或多个pod")]),t._v(" "),s("h3",{attrs:{id:"k8s的架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#k8s的架构"}},[t._v("#")]),t._v(" k8s的架构")]),t._v(" "),s("h4",{attrs:{id:"主节点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#主节点"}},[t._v("#")]),t._v(" 主节点")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("API服务器")]),t._v(". 用于部署和管理服务的REST API")]),t._v(" "),s("li",[s("strong",[t._v("Etcd")]),t._v(". 存储集群数据键值的NOSQL")]),t._v(" "),s("li",[s("strong",[t._v("调度器")]),t._v(". 选择要运行的pod的借点")]),t._v(" "),s("li",[s("strong",[t._v("控制器管理器")]),t._v(". 运行控制器, 确保集群状态和预期状态, 如自动启动和终止实例确保实例运行数量")])]),t._v(" "),s("h3",{attrs:{id:"普通节点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#普通节点"}},[t._v("#")]),t._v(" 普通节点")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("kubelet")]),t._v(" 创建和管理节点上运行的服务")]),t._v(" "),s("li",[s("strong",[t._v("kube-proxy")]),t._v(" 管理网络 包括pods的负载均衡")]),t._v(" "),s("li",[s("strong",[t._v("pods")]),t._v(" 应用程序服务")])]),t._v(" "),s("h4",{attrs:{id:"关键概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关键概念"}},[t._v("#")]),t._v(" 关键概念")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[t._v("pod")]),s("p",[t._v("k8s的基本部署单元, 由一个或多个共享IP和存储卷的容器组成, 一个微服务通常由单个容器组成, 例如JVM容器, 某些情况下, 会包含一个或多个实现支持功能的边车(sidecar)容器, 如nignx服务器有一个边车容器, 定期执行git pull更新最新版本的htm")])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[t._v("Depoyment")]),s("p",[t._v("Pod的声明规范, deplyment是一个控制器 . 用于确保始终运行的pod实例数量 , 通过滚动升级和回滚进行版本控制, 微服务架构中的每个服务都是一个depolyment")])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[t._v("service")]),s("p",[t._v("向应用程序服务的客户端提供一个静态/稳定的网络地址, 是基础设施提供的服务发下的一种形式, 内个service有一个具有一个ip和一个可解析为该ip地址的dns, 并跨一个或多个pod对tcp和udp流量进行负载均衡, 这个ip和dns只能在k8s内部访问(外部访问可配置)")])]),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"},[t._v("configmap")]),s("p",[t._v("用于定义一个或多个应用程序服务的外部化配置, pod容器的定义可以引用configmap来定义容器的环境变量 . 还可以使用configmap在容器内创建配置文件")])])])}),[],!1,null,null,null);s.default=_.exports}}]);